/**
 * AI Integration - OpenRouter Only
 */

import { Env, Activity, Transcript } from './types';

// Helper: Call OpenRouter API
async function callOpenRouter(prompt: string, apiKey: string, model: string): Promise<string> {
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

    if (!apiKey) {
        throw new Error('OpenRouter API key not configured');
    }

    const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`,
            'HTTP-Referer': 'https://monitorwatch.app',
            'X-Title': 'MonitorWatch',
        },
        body: JSON.stringify({
            model: model,
            messages: [{ role: 'user', content: prompt }],
            temperature: 0.7,
            max_tokens: 4096,
        }),
    });

    if (!response.ok) {
        const error = await response.text();
        console.error('OpenRouter API Error:', error);
        throw new Error(`OpenRouter API error: ${response.status} - ${error}`);
    }

    const data = await response.json() as any;
    const text = data.choices?.[0]?.message?.content;

    if (!text) {
        throw new Error('No content in OpenRouter response');
    }

    return text;
}


export async function generateNoteWithAI(
    activities: Activity[],
    transcripts: Transcript[],
    date: string,
    env: Env,
    aiConfig?: { provider: string; openRouterKey?: string; model?: string; language?: string }
): Promise<string> {
    const language = aiConfig?.language || 'en';
    const prompt = buildPrompt(activities, transcripts, date, language);
    const model = aiConfig?.model || 'google/gemini-2.0-flash-001';
    const apiKey = aiConfig?.openRouterKey || '';

    return await callOpenRouter(prompt, apiKey, model);
}

function buildPrompt(activities: Activity[], transcripts: Transcript[], date: string, language: string): string {
    const locale = language === 'pt' ? 'pt-BR' : 'en-US';
    const formattedDate = new Date(date).toLocaleDateString(locale);

    // Group activities by app
    const appGroups = new Map<string, Activity[]>();
    for (const activity of activities) {
        const key = activity.app_name;
        if (!appGroups.has(key)) {
            appGroups.set(key, []);
        }
        appGroups.get(key)!.push(activity);
    }

    // Build activities summary
    let activitiesSummary = '';
    for (const [app, acts] of appGroups) {
        const titles = [...new Set(acts.map(a => a.window_title).filter(Boolean))];
        const ocrTexts = acts.map(a => a.ocr_text).filter(Boolean).join('\n');

        activitiesSummary += `\n### ${app}\n`;
        activitiesSummary += `- Windows: ${titles.slice(0, 5).join(', ')}\n`;
        if (ocrTexts) {
            activitiesSummary += `- Context: ${ocrTexts.slice(0, 500)}...\n`;
        }
    }

    // Build transcripts summary
    let transcriptsSummary = '';
    if (transcripts.length > 0) {
        transcriptsSummary = '\n## Audio Transcripts\n';
        for (const t of transcripts) {
            transcriptsSummary += `- [${t.source}]: ${t.text.slice(0, 200)}...\n`;
        }
    }

    if (language === 'pt') {
        return buildPortuguesePrompt(formattedDate, date, activitiesSummary, transcriptsSummary);
    }
    
    return buildEnglishPrompt(formattedDate, date, activitiesSummary, transcriptsSummary);
}

function buildEnglishPrompt(formattedDate: string, date: string, activitiesSummary: string, transcriptsSummary: string): string {
    return `
# GENERATION INSTRUCTIONS

You are a personal assistant integrated with Obsidian.
Analyze the logs and create a direct, professional, and clean daily note.

## INPUT DATA
Date: ${formattedDate}

### ACTIVITIES
${activitiesSummary}

### TRANSCRIPTS
${transcriptsSummary}

---

## OUTPUT FORMAT (MARKDOWN)

Generate only the Markdown content below, no conversation.

---
date: ${new Date(date).toISOString().split('T')[0]}
type: daily-log
productivity_score: 8
mood: focused
---

# Daily Log: ${formattedDate}

## Summary
<Narrative paragraph about the day. Use tags (#project, #tech) and links ([[Link]]) naturally within sentences.>

## Deliverables & Focus
> [!SUCCESS] Highlights
> - [x] <Achievement 1>
> - [x] <Achievement 2>

### Technical Details
- **Project X**: ...
- **Tools**: ...

## Meetings & Insights
> [!quote] Conversations
> <Summary if there are transcripts.>

## Learning
- [[Concept]] studied.
- #tech/topic explored.

## Reflection
> [!question] Questions
> <3 brief questions.>

---
*Generated by MonitorWatch*

## RULES
1. **ZERO EMOJIS**.
2. **TAGS**: Use tags like #tag only within context or lists.
3. **LINKS**: Use [[WikiLinks]] to connect concepts.
4. **LANGUAGE**: Output strictly in English.
`;
}

function buildPortuguesePrompt(formattedDate: string, date: string, activitiesSummary: string, transcriptsSummary: string): string {
    return `
# INSTRU√á√ïES DE GERA√á√ÉO

Voc√™ √© um assistente pessoal integrado ao Obsidian.
Analise os logs e crie uma nota di√°ria direta, profissional e limpa.

## DADOS DE ENTRADA
Data: ${formattedDate}

### ATIVIDADES
${activitiesSummary}

### TRANSCRI√á√ïES
${transcriptsSummary}

---

## FORMATO DE SA√çDA (MARKDOWN)

Gere apenas o conte√∫do Markdown abaixo, sem conversas.

---
date: ${new Date(date).toISOString().split('T')[0]}
type: daily-log
productivity_score: 8
mood: focused
---

# Di√°rio: ${formattedDate}

## Resumo
<Par√°grafo narrativo sobre o dia. Use tags (#projeto, #tech) e links ([[Link]]) naturalmente no meio das frases.>

## Entregas & Foco
> [!SUCCESS] Highlights
> - [x] <Conquista 1>
> - [x] <Conquista 2>

### Detalhes T√©cnicos
- **Projeto X**: ...
- **Ferramentas**: ...

## Reuni√µes & Insights
> [!quote] Conversas
> <Resumo se houver transcri√ß√µes.>

## Aprendizado
- [[Conceito]] estudado.
- #tech/tema explorado.

## Reflex√£o
> [!question] Perguntas
> <3 perguntas breves.>

---
*Gerado por MonitorWatch*

## REGRAS
1. **ZERO EMOJIS**.
2. **TAGS**: Use tags como #tag apenas dentro do contexto ou listas.
3. **LINKS**: Use [[WikiLinks]] para conectar conceitos.
4. **IDIOMA**: Sa√≠da estritamente em Portugu√™s do Brasil.
`;
}

export async function generateMeetingNoteWithAI(
    activities: Activity[],
    transcripts: Transcript[],
    context: string,
    date: string,
    env: Env,
    aiConfig?: { provider: string; openRouterKey?: string; model?: string; language?: string }
): Promise<{ content: string; title: string }> {
    const language = aiConfig?.language || 'en';
    const prompt = buildMeetingPrompt(activities, transcripts, context, date, language);
    const model = aiConfig?.model || 'google/gemini-2.0-flash-001';
    const apiKey = aiConfig?.openRouterKey || '';

    const text = await callOpenRouter(prompt, apiKey, model);

    // Attempt to extract suggested title from response
    const titleMatch = text.match(/^#\s+(?:.*?)?\s*(.+)$/m);
    let title = context;
    if (titleMatch && titleMatch[1]) {
        title = titleMatch[1].trim()
            .replace(/^[üéôüíª]\s*/, '')
            .replace(/[<>:"/\\|?*]/g, '')
            .trim();
    }

    if (!title || title.length < 2) {
        title = language === 'pt' 
            ? `Nota - ${new Date().toLocaleTimeString('pt-BR')}`
            : `Note - ${new Date().toLocaleTimeString('en-US')}`;
    }

    return { content: text, title };
}

function buildMeetingPrompt(activities: Activity[], transcripts: Transcript[], context: string, date: string, language: string): string {
    let transcriptsSummary = language === 'pt' ? 'Nenhuma transcri√ß√£o dispon√≠vel.' : 'No transcripts available.';
    if (transcripts.length > 0) {
        transcriptsSummary = '';
        for (const t of transcripts) {
            transcriptsSummary += `- [${t.source}]: ${t.text}\n`;
        }
    }

    if (language === 'pt') {
        return buildPortugueseMeetingPrompt(activities, transcriptsSummary, context, date);
    }
    
    return buildEnglishMeetingPrompt(activities, transcriptsSummary, context, date);
}

function buildEnglishMeetingPrompt(activities: Activity[], transcriptsSummary: string, context: string, date: string): string {
    return `
# SYSTEM: CONTEXT AWARE NOTE GENERATOR

You are an expert personal data analyst integrated into Obsidian.
You receive a log of the last 2 hours of user activity (Apps & Audio).
Your goal is to identify the **Current Logical Session** and generate a high-quality Markdown note for it.

## INPUT DATA
Context Hint: "${context}" (Trigger Phrase)
Date: ${new Date(date).toLocaleString('en-US')}

### TRANSCRIPTS (Audio)
${transcriptsSummary}

### ACTIVITIES (App Usage)
${activities.map(a => `- [${new Date(a.timestamp).toLocaleTimeString('en-US')}] ${a.app_name}: ${a.window_title}`).join('\n')}

---

## YOUR TASK

1.  **SEGMENTATION**: Scan the logs backwards from the end. Identify when the *current* specific context started.
    *   If words like "Meeting", "Daily", "Sync" appear in audio -> It's a **Meeting**.
    *   If heavy usage of VS Code, Terminal, Xcode -> It's a **Coding Session**.
    *   If usage of Browser, YouTube, Reading -> It's a **Research/Study Session**.

2.  **EXTRACTION**: Extract *only* the information relevant to this specific identified session.

3.  **GENERATION**: Generate a specific Markdown note based on the detected type.

---

## OUTPUT FORMATS

### MODE A: MEETING (Default if audio conversation detected)
\`\`\`markdown
---
date: ${new Date(date).toISOString().split('T')[0]}
type: meeting
participants: [Me, <Detect>]
tags: [meeting, <Output>]
---

# <Title based on Topic>

## Executive Summary
<Brief summary of what was discussed>

## Key Points
- <Bullet point>
- <Bullet point>

## Action Items
> [!todo] Actions
> - [ ] <Action 1>

\`\`\`

### MODE B: CODING/WORK SESSION (If mostly App usage/Technical)
\`\`\`markdown
---
date: ${new Date(date).toISOString().split('T')[0]}
type: dev-log
tags: [dev, <Output>]
---

# <Title based on Project/Activity>

## Context
<What was being worked on>

## Changes & Details
- **<App/File>**: <Details based on Window Titles/OCR>

## Insights/Decisions
> [!tip] Tech Note
> <Technical decision or learning>
\`\`\`

---

## CRITICAL RULES
1.  **Auto-Detect Start Time**: Do not just summarize the whole 2 hours. Find the logical start.
2.  **English**: Output strictly in English.
3.  **No Fluff**: Be direct and concise.
4.  **No Emojis**: Zero emojis in output.
5.  **Output ONLY Markdown**: No conversational text.
`;
}

function buildPortugueseMeetingPrompt(activities: Activity[], transcriptsSummary: string, context: string, date: string): string {
    return `
# SISTEMA: GERADOR DE NOTAS CONTEXTUAL

Voc√™ √© um analista de dados pessoais especializado integrado ao Obsidian.
Voc√™ recebe um log das √∫ltimas 2 horas de atividade do usu√°rio (Apps e √Åudio).
Seu objetivo √© identificar a **Sess√£o L√≥gica Atual** e gerar uma nota Markdown de alta qualidade.

## DADOS DE ENTRADA
Dica de Contexto: "${context}" (Frase Gatilho)
Data: ${new Date(date).toLocaleString('pt-BR')}

### TRANSCRI√á√ïES (√Åudio)
${transcriptsSummary}

### ATIVIDADES (Uso de Apps)
${activities.map(a => `- [${new Date(a.timestamp).toLocaleTimeString('pt-BR')}] ${a.app_name}: ${a.window_title}`).join('\n')}

---

## SUA TAREFA

1.  **SEGMENTA√á√ÉO**: Analise os logs de tr√°s para frente. Identifique quando o contexto atual come√ßou.
    *   Se palavras como "Reuni√£o", "Daily", "Alinhamento" aparecem no √°udio -> √â uma **Reuni√£o**.
    *   Se uso intenso de VS Code, Terminal, Xcode -> √â uma **Sess√£o de C√≥digo**.
    *   Se uso de Browser, YouTube, Leitura -> √â uma **Sess√£o de Pesquisa/Estudo**.

2.  **EXTRA√á√ÉO**: Extraia *apenas* informa√ß√µes relevantes para esta sess√£o espec√≠fica.

3.  **GERA√á√ÉO**: Gere uma nota Markdown espec√≠fica baseada no tipo detectado.

---

## FORMATOS DE SA√çDA

### MODO A: REUNI√ÉO (Padr√£o se conversa detectada)
\`\`\`markdown
---
date: ${new Date(date).toISOString().split('T')[0]}
type: meeting
participants: [Eu, <Detectar>]
tags: [meeting, <Output>]
---

# <T√≠tulo baseado no T√≥pico>

## Resumo Executivo
<Breve resumo do que foi discutido>

## Pontos Principais
- <Ponto>
- <Ponto>

## Action Items
> [!todo] A√ß√µes
> - [ ] <A√ß√£o 1>

\`\`\`

### MODO B: SESS√ÉO DE C√ìDIGO/TRABALHO (Se principalmente uso t√©cnico)
\`\`\`markdown
---
date: ${new Date(date).toISOString().split('T')[0]}
type: dev-log
tags: [dev, <Output>]
---

# <T√≠tulo baseado no Projeto/Atividade>

## Contexto
<O que estava sendo trabalhado>

## Altera√ß√µes & Detalhes
- **<App/Arquivo>**: <Detalhes baseados em T√≠tulos/OCR>

## Insights/Decis√µes
> [!tip] Nota T√©cnica
> <Decis√£o t√©cnica ou aprendizado>
\`\`\`

---

## REGRAS CR√çTICAS
1.  **Auto-Detectar In√≠cio**: N√£o resuma as 2 horas inteiras. Encontre o in√≠cio l√≥gico.
2.  **Portugu√™s-Brasil**: Sa√≠da estritamente em PT-BR.
3.  **Sem Enrola√ß√£o**: Seja direto e conciso.
4.  **Sem Emojis**: Zero emojis na sa√≠da.
5.  **Apenas Markdown**: Sem texto conversacional.
`;
}
